# Recoding_Python2


2020.2.26 

python协程的逻辑



对比生成器版的协程，使用asyncio库后变化很大：

没有了yield 或 yield from，而是async/await
没有了自造的loop()，取而代之的是asyncio.get_event_loop()
无需自己在socket上做异步操作，不用显式地注册和注销事件，aiohttp库已经代劳
没有了显式的** Future** 和** Task，asyncio**已封装
更少量的代码，更优雅的设计

协程的逻辑:
定义协程---创建loop---创建task(asyncio.create_task将协程打包成task)-task接入loop---用await(挂起当前任务,切换用的,类似生成器里yield切换函数的作用) 等待task



使用async可以定义协程,协程用于耗时的IO操作,也可以封装更多的IO操作过程,在一个协程中await另外一个协程实现洗成的其那套

可等待对象:如果一个对象可以在await语句中使用,那么它就是可等待对象呢
许多asyncio API都被设计为接收可等待对象


可等待对象有三种类型:协程,任务和Future

协程:python中的协程属于可等待对象,所有可以在其他协程中被等待
任务是用来设置日程以便并发执行协程

当一个协程通过asyncio.create_task()等函数被打包成一个任务,该协程
将自动排入日程准备立即执行


尝试使用协程写一个爬虫(协程还是函数维度的编程)

以后就多玩协程,线程.协程更好,值切换上下文;线程还要缓存,会有性能消耗


io密集用协程
CPU密集用多进程

2020.2.29


进程  vs 线程

进程是资源分配分配的独立单位,线程是操作系统调度的基本执行单位
一个程序中默认有一个主进程,一个进程中默认有一个主线程
进程间不共享数据,线程间是共享数据
多进程和多线程的执行顺序是无序的
程序会等待有进程结束后再关闭对出,进程结束则关闭释放资源
进程结束,此进程里的多线程会强制关闭释放资源
可以在进程中加上time.sleep来暂缓进程的技术

多线程:(cpython中的存在的GIL问题)

创建Thread类对象----开启线程---join():阻塞等待某个子线程结束(多个线程则需要多个thd.join())---threading

1.创建开启子线程
	1.创建Thread类对象
	python
	import threading #实际上threading是对Thread二次封装,
	thd = threading.Thread(target=funcName,args=(位置参数,),
	kwargs={key:val,...})
	2. 开启线程

2. 等待子线程结束 两步
	1.join():等待阻塞某个子线程结束--->多个线程则需要多个thd.join()
	2.theading.enumerate():查看当前线程数量,当前线程数量为1时,则子线程结束
	3. 创建子线程的另一种方式(继承threading.Thread方便代码封装)

	4. 多线程间是共享数据(因为在同一个进程中),同时修改同一数据时可能导致数据竞争
	解决多线程共享数据引起竞争的问题-互斥锁,包含所的多线程程序,其实就编程了并发模式,好处:保证正确执行,坏处:效率降低,处理不好容易死锁

	lock = threading.Lock() # 申请加锁
	lock.acquirte()# 加锁并阻塞,返回TorF 判断是否成功 成功往下,反之阻塞
	待加锁代码块

	lock.release() #解锁 并解除阻塞

加的次数越大越容易出现资源竞争,阻塞等待


5.避免死锁办法
	１．死锁的产生
		多线程中加锁的过程中．两个锁住的代码相互引用，导致资源不能释放(死锁)
	２．银行家算法(资源的合理利用的方法)
	３．　添加超时时间(不太好)
		１．lock.acquire(True,10)
		a.第一个参数默认True:是否阻塞等待
		b.第二个参数默认-1:表示一直阻塞　改为10:10秒后解除锁不继续阻塞


６．扩展

	1.GIL:全局解释器(相当于一个大的互斥锁)

	c语言写的Python解释器中存在，一个进程中有一个GIL来控制多线程之间资源，所以cpython中多线程为并发，无论多少核cpu,同一时间点，只有一个线程在运行，
不能完全利用CPU(利用率永远达不到100%,多进程可以)


	2.GIL产生历史原因

	python 编写是电脑只有单核，为了单核CPU上的多线程，便使用GIL来实现
多线程

	３．　GIL解决方法
		a.使用其他语言写的pyton解释器(不推荐，还是cpython)
		b.不使用多线程，使用多进程－进程里加协程来实现多任务
			来充分利用多核cpu(推荐)
		c.引用c语言实现的多线程模块


	４．　即使存在GIL在有IO等待操作的程序中，还是多线程较快，当然
		没有资源等待的还是单线程块(科学计算，累加等)




多进程


进程的三种典型状态切换－１．就绪态(ready)2.运行态(running) 3.阻塞态(block)


实现多进程实际上就是子进程赋值父进程的资源，所以资源不共享


１．声明开启子进程
pro = multiprocessing.Process(target=funcName, args=(xx,))

pro.start() # 给操作系统发送一个创建执行子进程的信号,这个过程是需要一定的时间

2. pro.is_alive():判断继承是否存活
３．　pro.join([timeout]):一直阻塞子进程pro结束，或阻塞多少秒就不管
４．　pro.terminate()：不管任务是否完成，立即终止子进程
注意：这个立即结束是向操作系统发出终止命令，需要0.01s
	一般terminate()然后join这两个一起用

5. 进程间的通信－队列(queue) ,特点：先进先出
	１．　创建一个队列　原理就是多个子进程共用一个队列
 		multiprocessing.Queue([maxsize])
	2.队列的常用方法
		a. Queue.qsize()　返回当前队列的消息数量
		b. Queue.empty()　如果队列为空，返回True
		c.Queue.full()　如果队列满了，返回True,当队列满了时，
			在添加元素，会阻塞等待直至添加成功
		d.Queue.get([block[,timeout]]) 获取队列中第一条消息，
然后从队列移除，block,默认True阻塞效果，有时间设置的话，时间到了还阻塞就抛出异常
		e. Queue.get_nowait() 相当于Queue.get(False)拿不到就直接抛出异常，没有阻塞效果

		f.Queue.put(item[;timeout]) 往队列队尾放数，队列满时，
会阻塞，直到有位置放数据，timeout时间到且sie==maxsize则抛出异常
		g.Queue.put_nowait()相当于Queue.put(item,False)往队列中放数据了，则直接抛出异常




6. 进程的pid

	pro.pid　这个是属性值：或这os.getpid()


7. 扩展

进程是操作系统资源分配的基本单位
进程间是独立的数据空间，相当于子进程复制了一份代码出来，so不共享全局变量，但是
一个进程中多线程是共享全局变量的

ps -aux 查看系统中所有进程信息
ps -ef 可以查看父级的ip(ppid)

top 动态显示进程信息
htop: 动态显示进程信息，并显示系统资源使用情况

孤儿进程：父进程挂了，子进程还在运行
父进程回收子进程资源通过其init来回收，父进程挂了就由系统的init来
僵死进程：子进程退出，父进程没有回收子进程的资源，坏处：占用系统资源
但是python是高级语言，不用处理，可以自动回收，
下次再创建子进程时会复用之前的僵死进程资源，目的是为了减少资源的浪费，
并加速进程的创建


进程池


１．进程池概论

提前创建一定数量的进程，任务数多于进程池最大进程数量时，就等待某个进程结束，
来运行下一个任务；重复使用这些进程

特点：
节省重复创建进程的时间以及销毁的系统开销
自动会进程池中的进程进行管理
提高了对用户需求的响应效果


工作进程－－就是进程池中的进程
管理进程－就是主进程，维护进程池，也叫作控制进程


2.步骤


１．创建一个进程池
    pool = multiprocessing.Pool(3) 
 # 3代表最大进程数同时运行  ****但是一开始就已创建3个工作进程 加上主进程就是4个   不写就是系统最大的进程数 和CPU核数有关

２．创建进程池中的通信

    queue = multiprocessing.Manager().Queue(4)  # 用法和上面一致


3.添加任务

 pool.apply(func=funct_xxx,args=(1,))   # 添加任务并且阻塞等待任务执行完成   能保证顺序
    pool.apply_async(func=funct_xxx,args=(2,))  # 异步添加任务  不阻塞等待任务执行完成   ***用的多
 # 4,关闭进程池
    pool.close()
    pool.join()    ## 必须放在close或者terminate之后使用;
    print("关闭进程池")


简单总结

１．进程资源分配的单位
２．线程是操作系统调度的单位
３．进程切换需要的资源最大，效率很低
４．线程切换需要的资源一般，效率一般（不考虑GIL时）
５．协程切换任务资源很小，效率高
６．多进程，多线程根据cpu核数不同可能是并行的，但是协程是在一个线程中所以是并发的

７．一般情况下，使用多进程加协程实现多任务





python3多任务--线程,进程以及协程


多任务:

并发:同一时间段执行多个任务-->如,单核,基于时间片的CPU轮转
并行:同一时间点执行多个任务--->如,多核


实现方式有,进程,线程和协程(代码层)


进程  vs 线程

进程是资源分配分配的独立单位,线程是操作系统调度的基本执行单位
一个程序中默认有一个主进程,一个进程中默认有一个主线程
进程间不共享数据,线程间是共享数据
多进程和多线程的执行顺序是无序的
程序会等待有进程结束后再关闭对出,进程结束则关闭释放资源
进程结束,此进程里的多线程会强制关闭释放资源
可以在进程中加上time.sleep来暂缓进程的技术


多线程:(cpython中的存在的GIL问题)

创建Thread类对象----开启线程---join():阻塞等待某个子线程结束(多个线程则需要多个thd.join())---threading

1.创建开启子线程
	1.创建Thread类对象
	python
	import threading #实际上threading是对Thread二次封装,
	thd = threading.Thread(target=funcName,args=(位置参数,),
	kwargs={key:val,...})
	2. 开启线程

2. 等待子线程结束 两步
	1.join():等待阻塞某个子线程结束--->多个线程则需要多个thd.join()
	2.theading.enumerate():查看当前线程数量,当前线程数量为1时,则子线程结束
	3. 创建子线程的另一种方式(继承threading.Thread方便代码封装)

	4. 多线程间是共享数据(因为在同一个进程中),同时修改同一数据时可能导致数据竞争
	解决多线程共享数据引起竞争的问题-互斥锁,包含所的多线程程序,其实就编程了并发模式,好处:保证正确执行,坏处:效率降低,处理不好容易死锁

	lock = threading.Lock() # 申请加锁
	lock.acquirte()# 加锁并阻塞,返回TorF 判断是否成功 成功往下,反之阻塞
	待加锁代码块

	lock.release() #解锁 并解除阻塞

#这个原理其实是冻结两个代码块，释放一个才会执行第二个代码块
#相当于两个车道，在特定的范围，变单车道



	 # 将锁传入线程中
    hello_thd = threading.Thread(target=hello,args=(lock,))
    world_thd = threading.Thread(target=world,args=(lock,))

    hello_thd.start()
    world_thd.start()

    hello_thd.join()
    world_thd.join()


加的次数越大越容易出现资源竞争,阻塞等待


5.避免死锁办法
	１．死锁的产生
		多线程中加锁的过程中．两个锁住的代码相互引用，导致资源不能释放(死锁)
	２．银行家算法(资源的合理利用的方法)
	３．　添加超时时间(不太好)
		１．lock.acquire(True,10)
		a.第一个参数默认True:是否阻塞等待
		b.第二个参数默认-1:表示一直阻塞　改为10:10秒后解除锁不继续阻塞


６．扩展

	1.GIL:全局解释器(相当于一个大的互斥锁)

	c语言写的Python解释器中存在，一个进程中有一个GIL来控制多线程之间资源，所以cpython中多线程为并发，无论多少核cpu,同一时间点，只有一个线程在运行，
不能完全利用CPU(利用率永远达不到100%,多进程可以)


	2.GIL产生历史原因

	python 编写是电脑只有单核，为了单核CPU上的多线程，便使用GIL来实现
多线程

	３．　GIL解决方法
		a.使用其他语言写的pyton解释器(不推荐，还是cpython)
		b.不使用多线程，使用多进程－进程里加协程来实现多任务
			来充分利用多核cpu(推荐)
		c.引用c语言实现的多线程模块


	４．　即使存在GIL在有IO等待操作的程序中，还是多线程较快，当然
		没有资源等待的还是单线程块(科学计算，累加等)




多进程


进程的三种典型状态切换－１．就绪态(ready)2.运行态(running) 3.阻塞态(block)


实现多进程实际上就是子进程赋值父进程的资源，所以资源不共享


１．声明开启子进程
pro = multiprocessing.Process(target=funcName, args=(xx,))

pro.start() # 给操作系统发送一个创建执行子进程的信号,这个过程是需要一定的时间

2. pro.is_alive():判断继承是否存活
３．　pro.join([timeout]):一直阻塞子进程pro结束，或阻塞多少秒就不管
４．　pro.terminate()：不管任务是否完成，立即终止子进程
注意：这个立即结束是向操作系统发出终止命令，需要0.01s
	一般terminate()然后join这两个一起用

5. 进程间的通信－队列(queue) ,特点：先进先出
	１．　创建一个队列　原理就是多个子进程共用一个队列
 		multiprocessing.Queue([maxsize])
	2.队列的常用方法
		a. Queue.qsize()　返回当前队列的消息数量
		b. Queue.empty()　如果队列为空，返回True
		c.Queue.full()　如果队列满了，返回True,当队列满了时，
			在添加元素，会阻塞等待直至添加成功
		d.Queue.get([block[,timeout]]) 获取队列中第一条消息，
然后从队列移除，block,默认True阻塞效果，有时间设置的话，时间到了还阻塞就抛出异常
		e. Queue.get_nowait() 相当于Queue.get(False)拿不到就直接抛出异常，没有阻塞效果

		f.Queue.put(item[;timeout]) 往队列队尾放数，队列满时，
会阻塞，直到有位置放数据，timeout时间到且sie==maxsize则抛出异常
		g.Queue.put_nowait()相当于Queue.put(item,False)往队列中放数据了，则直接抛出异常




6. 进程的pid

	pro.pid　这个是属性值：或这os.getpid()


7. 扩展

进程是操作系统资源分配的基本单位
进程间是独立的数据空间，相当于子进程复制了一份代码出来，so不共享全局变量，但是
一个进程中多线程是共享全局变量的

ps -aux 查看系统中所有进程信息
ps -ef 可以查看父级的ip(ppid)

top 动态显示进程信息
htop: 动态显示进程信息，并显示系统资源使用情况

孤儿进程：父进程挂了，子进程还在运行
父进程回收子进程资源通过其init来回收，父进程挂了就由系统的init来
僵死进程：子进程退出，父进程没有回收子进程的资源，坏处：占用系统资源
但是python是高级语言，不用处理，可以自动回收，
下次再创建子进程时会复用之前的僵死进程资源，目的是为了减少资源的浪费，
并加速进程的创建


进程池


１．进程池概论

提前创建一定数量的进程，任务数多于进程池最大进程数量时，就等待某个进程结束，
来运行下一个任务；重复使用这些进程

特点：
节省重复创建进程的时间以及销毁的系统开销
自动会进程池中的进程进行管理
提高了对用户需求的响应效果


工作进程－－就是进程池中的进程
管理进程－就是主进程，维护进程池，也叫作控制进程


2.步骤


１．创建一个进程池
    pool = multiprocessing.Pool(3) 
 # 3代表最大进程数同时运行  ****但是一开始就已创建3个工作进程 加上主进程就是4个   不写就是系统最大的进程数 和CPU核数有关

２．创建进程池中的通信

    queue = multiprocessing.Manager().Queue(4)  # 用法和上面一致


3.添加任务

 pool.apply(func=funct_xxx,args=(1,))   # 添加任务并且阻塞等待任务执行完成   能保证顺序
    pool.apply_async(func=funct_xxx,args=(2,))  # 异步添加任务  不阻塞等待任务执行完成   ***用的多
 # 4,关闭进程池
    pool.close()
    pool.join()    ## 必须放在close或者terminate之后使用;
    print("关闭进程池")


协程


协程，微线程，并发

协程是提高单核最大效率，必须要有阻塞才会有效果提升
比线程还要少占用
原理　切换用户层面的切换机制

在一个线程中的某个函数，可以在任何地方保存当前函数的一些临时变量等信息，
然后切换到另一个函数中执行，注意不是通过调用函数的方式做到的，
并且切换的次数以及什么时候再切换回来都由开发者去顶


协程与线程的禅意

在实现多任务时, 线程切换从系统层面远不止保存和恢复 CPU上下文这么简单。 操作系统为了程序运行的高效性每个线程都有自己缓存Cache等等数据，操作系统还会帮你做这些数据的恢复操作。 所以线程的 切换非常耗性能。但是协程的切换只是单纯的操作CPU的上下文，所以一秒钟切换个上百万次系统都抗的住。

简单实现协程

１．yield
	挂起当前执行的代码
	恢复代码继续执行


greenlet
gevent
asyncio


简单总结

１．进程资源分配的单位
２．线程是操作系统调度的单位
３．进程切换需要的资源最大，效率很低
４．线程切换需要的资源一般，效率一般（不考虑GIL时）
５．协程切换任务资源很小，效率高
６．多进程，多线程根据cpu核数不同可能是并行的，但是协程是在一个线程中所以是并发的

７．一般情况下，使用多进程加协程实现多任务
